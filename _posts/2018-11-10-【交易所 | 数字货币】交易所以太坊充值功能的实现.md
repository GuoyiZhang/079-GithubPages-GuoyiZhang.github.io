---
layout:     post
title:      【交易所 | 数字货币】交易所以太坊充值功能的实现
subtitle:   【交易所 | 数字货币】交易所以太坊充值功能的实现
date:       2018-11-10 09:16:47
author:     Sunny day
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
---

>【交易所 | 数字货币】交易所以太坊充值功能的实现

# 【交易所 | 数字货币】交易所以太坊充值功能的实现


主要开发语言是ruby，流程大概是，钱包生成使用以太坊go-ethereum，生成的keystroe使用py-ethereum解析成private_key，签名transaction用node，再用ruby封装的json rpc client发送到以太坊主网。

虽然听起来就绕来绕去的，但是目前转private_key的方法应该只有python的客户端支持，签名transaction的方法也只有node的web3有支持，发送到以太坊主网可以很多办法，就是post一下，用ruby也就是因为熟悉。

具体步骤：

1. 从用户注册开始，需要生成一个以太坊钱包，需要安装go-ethereum，安装方法自行google。生成钱包的命令：

str = `geth --datadir /#{ENV['DATADIR']} account new --password /#{file.path}`

DATADIR是go-ethereum的数据目录，生成的钱包keystore会存到这个目录下，file.path是事先准备好的密码写进文件。

 

2. 通过etherscan的api监听全部transaction，接口是

url = "http://api.etherscan.io/api?module=account&action=txlist&address=/#{address}&startblock=0&endblock=99999999&sort=desc&apikey=/#{API_KEY}"

然后通过判断返回每个transaction的to字段是否等于address，来判断这条记录是否为转入记录，confirmations来判断确认数，通常大于12个确认数就可以了，isError来判断这条记录是否转账异常，再判断数据库是否已经存在这条记录，如果不存在，就存进数据库，并在用户余额上加上这个数字。

 

3. 通过infura的json rpc监听钱包余额，大于0的就把余额转入热钱包，这里就是比较复杂的一步了。

 

实现方法有很多，我的方法应该比较烂，仅供参考：

1. 引用gem 'ethereum'，配置：

host = "mainnet.infura.io" 

        port = "443" 

        ssl = true

$eth_client = Ethereum::HttpClient.new(host, port, ssl)

2. 请求检查钱包余额

$eth_client.get_balance address, "latest"

3. 获取钱包nonce

        $eth_client.get_transaction_count address, "latest"

4. 通过python把keystore和password转化成private_key，这里是把py-ethereum里转化private_key的代码提取出来了，做成一个专门的脚本。

%x(python3 decode_keystore_json.py /#{keystore} /#{password}).gsub("\n", "")

5. 通过node签名transaction拿到raw_data，最后的data为空字符串，转账ERC20的时候才会用到，签名transaction的node脚本，随便在Stack Overflow上搜一搜答案很多，需要注意的是每个字段都要转成16进制格式，这是以太坊的bug，可能0和1的时候是没问题的，超过1就会返回奇怪的错误，这个坑了我很长时间，加粗提醒。

%x(node sign_transaction.js /#{to} /#{hex(amount)} /#{private_key} /#{hex(GAS_PRICE)} /#{hex(GAS_LIMIT)} /#{hex(nonce)} /#{hex(CHAIN_ID)} /#{data})

6. 发布transaction到以太坊主网，这一步会拿到返回的tx_hash，用于追踪转账情况。

$eth_client.send_raw_transaction(raw_data)

 

结束了，细节很多，就不仔细写了，大概就是处理好每个状态，定时任务去检查transaction的状态，因为要做足日志，给用户看记录，显得我们足够专业，给后台留条后路，万一出现问题，得知道怎么去处理，核心逻辑就上面这些了。

